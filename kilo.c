/*** includes ***/

#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <termios.h>
#include <unistd.h>

/*** data ***/

struct termios originalTermios;

/*** terminal ***/

// Обработчик ошибок. `tcsetattr`, `tcgetattr` и `read` возвращают `-1` в случае неудачи и устанавливают глобальную
// переменную `errno`. `perror` использует `errno` и дополнительно выводит переданную строку.
// Чтобы намеренно вызвать ошибку в `tcgetattr`, нужно в командной строке передать файл или ввод через `|`:
// - `./kilo < kilo.c`
// - `echo test | ./kilo`
// Обе команды выведут: tcgetattr: Inappropriate ioctl for device
void die(const char *s) {
	perror(s);
	exit(1);
}

// Восстанавливает `canonical`-режим терминала
void disableRawMode() {
	if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &originalTermios) == -1) {
		die("tcsetattr");
	}
}

// Терминал может работать в `canonical`- или `cooked`-режиме или в `raw`-режиме. По умолчанию используется
// `canonical`-режим. В этом режиме ввод с клавиатуры направляется в программу только после нажатия клавиши `Enter`.
// В программах со сложным пользовательским интерфейсом, например, в текстовых редакторах, необходимо обрабатывать
// каждое нажатие клавиши и тут же выводить в интерфейс то, что набрано с клавиатуры. Это можно сделать в `raw`-режиме,
// однако, какого либо простого переключателя в этот режим нет. Нужно установить несколько флагов в терминале.
void enableRawMode() {
	// считываем атрибуты терминала
	if (tcgetattr(STDIN_FILENO, &originalTermios) == -1) {
		die("tcgetattr");
	}

	// установка обработчика выхода (восстанавливаем режим терминала)
	atexit(disableRawMode);

	struct termios raw = originalTermios;

	// меняем атрибуты
	// Флаг `BRKINT` выключается традиционно (скорее всего он уже выключен, трационность в его явном выключении). Если он
	// включен, условие прерывания спровоцирует отправку `SIGINT` процессу.
	// Флаг `INPCK` отвечает за проверку паритета, что, кажется, не актуально для современных эмуляторов терминалов.
	// Флаг `ISTRIP` отвечает за обнуление 8 бита каждого введенного байта.
	// Флаг `ICRNL` позволяет отключить автоматическое преобразование перевода каретки (`\r`) в новую строку (`\n`). Для
	// перевода каретки используется сочетание клавиш `Ctrl+M`, поэтому использование этого флага исправляет поведение
	// `Ctrl+M`. Однако, оно также поменяет код, возвращаемый клавишей `Enter`. Если флаг не отключить, и `Ctrl+M`, и
	// `Enter` вернут 10. Если отключить, , и `Ctrl+M`, и `Enter` вернут 13.
	// Флаг `IXON` позволяет отключить сочетания клавиш `Ctrl+S` и `Ctrl+Q`, которые управляют передачей данных терминалу.
	raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
	// Битовая маска `CS8`. Устанавливает размер символа (CS) в 8 бит на байт.
	raw.c_cflag |= ~(CS8);
	// Флаг `ECHO` отвечает за вывод на экран символов, которые соответствуют нажимаемым клавишам. Это полезно в
	// `canonical`-режиме, но будет мешать при выводе интерфейса.
	// `c_lflag` - `local flags`. В комментариях в `termios.h` для `macOs` это поле описывается как свалка для разных
	// флагов. Кроме `c_lflags` есть еще `c_iflag` (флаги ввода), `c_oflag` (флаги вывода) и `c_cflag` (управляющие
	// (`control`) флаги).
	// `ECHO` - битовый флаг. Инвертируем его операцией побитового отрицания (длина - 32 бита). После побитового
	// отрицания, применяем операцию побитового "И" для установки значения флага в поле флагов.
	// Флаг `ICANON` позволяет выключить `canonical`-режим и считывать ввод байт за байтом вместо строки за строкой.
	// Флаг `IEXTEN` позволяет выключить использования сочетания клавиш `Ctrl+V` для расширенного ввода.
	// Флаг `ISIG` позволяет выключить отправку сигналов `SIGINT` и `SIGTSTP` процессу. Эти сигналы отправляются по
	// сочетанию клавиш `Ctrl+C` и `Ctrl+Z`.
	raw.c_lflag &= ~(ECHO | IEXTEN | ICANON | ISIG);
	// Флаг `OPOST` позволяет выключить преобразование `\n` в `\r\n` при выводе. Это единственная опция обработки вывода,
	// включенная по умолчанию. Если выключить преобразование, `printf` будет переводить курсор на новую строку, но не
	// будет возвращать его в начало строки.
	raw.c_oflag &= ~(OPOST);

	// Поле `cc` - `control characters`, управляющие символы - является массивом байтов, которые отвечают за различные
	// настройки терминала.
	// `VMIN` устанавливает минимальное число байт ввода чтобы вызов `read` что-то вернул. Установка `0` заставляет `read`
	// возвращать любой ввод сразу же.
	// `VTIME` - максимальное время ожидания перед тем как `read` вернет результат. Значение измеряется в десятых долях
	// секунды, поэтому `1` - это 100 миллисекунд. По прошествии этого времени `read` вернет `0` (это имеет смысл, т.к.
	// обычно `read` возвращает число прочитанных байт).
	raw.c_cc[VMIN] = 0;
	raw.c_cc[VTIME] = 1;

	// устанавливаем атрибуты
	// `TCSAFLUSH` определяет, когда применить изменения. В данном случае, программа ждет записи в терминад всех
	// выводов, находящися в процессе ожидания и отбрасывает любой ввод, который еще не был прочитан.
	// `TCSAFLUSH` используется также в `disableRawMode`. Пожтому остаток ввода не отдается терминалу после выхода из
	// программы. Если этого не делать, то при вводе строки `123q456` программа последовательно будет считывать символы,
	// дойдя до `q` осуществит выход, а `456` будет воспринята как команда терминала. При использовании флага `ICANON`
	// работа программы изменится, т.к. будет работать считываение ввода байт за байтом. Поэтому, при нажатии `q` будет
	// осуществляться выход.
	if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw) == -1) {
		die("tcsetattr");
	}
}

int main() {
	enableRawMode();

	while(1) {
		char c = '\0';

		// в `Cygwin` по истечении таймаута `read` возвращает -1 и устанавливает `errno` в `EAGAIN` вместо того, чтобы
		// возвращать `0`. Поэтому в `Cygwin` не считаем `EAGAIN` за ошибку.
		if (read(STDIN_FILENO, &c, 1) == -1 && errno != EAGAIN) {
			die("read");
		}

		if (iscntrl(c)) {
			printf("%d\r\n", c);
		} else {
			printf("%d ('%c')\r\n", c, c);
		}

		if (c == 'q') {
			break;
		}
	}

	return 0;
}
